写作时间：2019年10月10日14:30:32

### Annotation 注解

#### 注释： 解释自己的代码。 
单行注释：//  

多行注释：/*   */   

文档注释： /**   */

#### 注解：  

##### 1. 注解的写法： @XXX[（一些信息）]

##### 2. 注解放置在：   
类的上面 属性上面，方法上面，构造方法上面，参数前面  
块上不能放注解，因为块找不到，无法准确向块中传递信息。）
##### 3. 注解的作用：  
  * 充当注释（是一个文字的说明，但是不影响使用 ex:已经过时的方法前会有@Deprecated）
  * 用来做代码的检测（验证）。ex：@Override 如果不满足重写要求，会报错。
  * 可以携带信息（内容）  
    * 用文件 .properties .xml 放在当前包下，用来增强程序的复用性，修改内容灵活。但是文件和代码不在一起，开发的时候较麻烦。  
    * 注解是写在代码里面，开发的时候更加灵活，不好处是代码被封装打压之后，内容就无法再修改了。
    * 现在更多的是用注解的方式来配置，因为应用的时候配置文件少有改动，而快速开发又很重要。
##### 4. Java已有的注解  
* @Deprecated 用来说明方法是废弃的。  
* @Override 检测此方法是否是重写  
* @SuppressWarnings(参数)  参数是String类型的数组 String[] {"",""}  
  * unused：变量定以后未被使用表示不要报“未使用警告”，我还没用。  
  * 省略其他可用参数，用到再查，几乎用不到！  
  * 如果只传一个参数，可以省略大括号。尽量不要用SuppressWarnings()，有问题就解决

##### 5. 注解可以带信息，也可以不带信息 ，带信息的类型只能如下：  
   * 基本数据类型
   * String 类型
   * 枚举类型 Enum
   * 注解类型   
   * 数组类型[] 数组的内部只能是如上四种类型。 
   
##### 6. 如何自己搞一个注解   
1. 通过@interface来定义新的注解类型。  
2. 发现写法跟接口非常相似，可以利用接口的特点帮助记忆。  
  * 可以描写 public static final 的属性，但是比较少见，因为是final的  
  * 可以描写 public abstract 的方法，但是必须要有返回值，类型是5所列的类型。  
  方法的作用是将传递给注解的参数搬运给下面的变量。  
   可以添加默认值：  方法() default 默认值;
3. 注解定义之后，还需要说明才能使用  
  * 利用元注解 （也是注解，不是拿来使用的，是用来说明注解的。）  
    * @Target 描述当前注解放在哪儿的。  
  参数得是个ElementType类型 是个枚举类型 可以写成：ElementType.FIELD。 也可以写：FIELD （要导入合适的包。）  
    * @Retention 描述当前注解存在什么作用域中。  
  源代码文件SOURCE--> 编译--> 字节码文件CLASS--->加载--->内存执行RUNTIME。   
    * @Inherited 描述当前注解是否能被子类对象继承。只是个说明，没有参数。  
    * @Document 描述注解能否被文档所记录。  
  后两个注解不常用
4. 自己使用自己描述的注解  
* 1. 问题1：注解里描述了方法，但是方法没有参数只有返回值。但是使用时，让我们传递参数。  
理解为：注解的方法将我们传递给他的参数再传递给别的位置（给使用时注解下面那个位置）
* 2. 使用别人写好的注解不用谢方法名，自己定义的方法必须写名字？  
答：当注解类中只有一个方法，且方法名字为vlaue() 时，用的时后方法名便可以省略  @MyAnn(value="参数") @myAnn("参数")  
如果注释类 方法有两个以上，每一个方法必须写名字。顺序无所谓。

#### 如何利用反射技术 解析注解（获得注解内部携带的信息） 
1. 获取Class
2. 获取类中的成员 类 属性 方法 构造方法
3. Annotation a = 成员.getAnnotation(注解类型.class);
4. 注解对象，执行方法获取返回结果。

