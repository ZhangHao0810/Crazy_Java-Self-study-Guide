2019.6
## 第六章：接口与抽象类（深入多态）
接口是多态和Java的重点。没有接口机制就没法活下去。  
`Animal a = new Animal（）；`让人感到奇怪，animal是什么动物？不应该有animal实例被new出来。

#### 抽象类
1.	在类声明前面加上 abstract 就是抽象类了。抽象类不能创建任何类型的实例，但是可以用抽象的类型作为引用类型给多态使用。设计继承结构时，必须决定好哪些类时抽象的，哪些是具体可以被初始化为对象的。
2.	抽象类除了被继承之外，没有用途，没有值，没有目的（除了抽象的 class 可以有static的成员 （10章谈）
3.	抽象方法咩有实体！含有抽象方法的类必须标为抽象。抽象方法存在的意义就是给子类们一个共同的协议！好处就是 多态！所有子类型都会有那些抽象的方法。
4.	抽象的方法必须在具体的类中运行。
5.	不是抽象的类就被称为具体类。第一个具体类必须实现所有的抽象方法。
#### Object类（java.lang.Object）有什么？：
   - a)	equals（Object o）判断对象是否与其他对象相等。
   - b)	getClass() 告诉对象是从哪里被初始化的。
   - c)	hashCode() 列出对象的哈希代码（相当于唯一ID）
   - d)	toString() 列出类的名称和一个其他的数字。
1.	Object不是正式的Java抽象类，因为可以被所有类继承下来的方法都有方法体。所以没有需要必须被重写的方法。
2.	建议重写hashCode() 、equals() 、toString()。不是所有Object方法都可被重写，有的方法有final标记。
3.	Object类时具体的，可以创造出Object的实例对象，因为有时会需要一个通用的，轻量化的对象。最常见的用途是在线程的同步化上面（15章）
4.	Object的作用：作为多态让方法可以应付多种类型的机制。提供java执行期间对任何对象都需要的方法体。（让所有的类都被继承）。有一部分方法与线程有关。
5.	Java是类型检查很强的程序，你只能从确实有该方法的类中调用该方法。类型安全检查。这就是不把所有的参数和返回类型都设置为Object的原因。  
`Object o = new Dog();	 o.eat();`   //非法的。
6.	使用Object有代价：`ArrayList <Object>`
   - a)	放进去的对象是猫狗鱼，出来后都变成了Object类的实例。
   - b)	Object无法赋值给猫狗鱼的引用。无法通过编译，编译器无法确定它是猫狗还是鱼。
   - c)	所以一定注意，返回值类型是Object时，不能赋值给其他类型的引用。但是其他任何类型的引用/对象都可以赋值给Object类型的引用。  要通过IS-A测试的。
7.	编译器是根据引用类型来判断有哪些方法可以调用，而不是看对象的类型。
    - a)	Object o = new Dog();  引用o不能叫。因为Object类没有叫这个方法。
8.	当把对象装进`ArrayList<Object>`中时，不管他原来是什么，你只能吧它当成是Object。取出引用时，引用的类型只会是Object。
当你确定时，可以强制转换成原来的类型：  
	`Object o = new Dog();`
	`Dog d = (Dog) o;`  
	`d.eat();`  
如果不确定是个Dog，使用Instanceof运算符来检查，错了的话抛出ClassCastException  
`if (o instanceof Dog){
	Dog d = (Dog) o;
}`

9.	把类的公有方法当做是合约的内容，合约是我对其他程序的承诺协议

#### 接口：
1.	接口的所有方法都是抽象的，没有内容，以分号结束。
    - a)	public interface Pet{
    - public abstract void play();   } 抽象方法用abstract修饰。
    - b)	public class Dog extends Animal implements Pet {…}
2.	实现接口，必须实现接口中的所有抽象方法（写出方法体），  
继承抽象类（含有抽象方法的类即抽象类），也必须重写所有的抽象方法，非抽象的方法无所谓。  
继承非抽象类，重写与否都无所谓。  
*所以只要我上面有抽象方法，我就都得重写，不然就不要继承或者实现。*

3.	接口的作用：  
不管你来自哪里，只要你实现这个接口，别人就会知道你一定会履行某些合约。
好的设计不需要在抽象类中定义实现细节（方法体），让细节在具体的子类上实现是合理的。

4.	类可以实现多个接口，不同继承树上的类可以实现同一个接口！！非常重要。  
而类当多态来使用的时候，必须来自同一颗继承树。Animal引用不能接受 fire类。

5.	如何设计：  
    - 类无法对其他的类通过IS-a测试时，设计不继承其他类的类。  
	- 在需要类的特殊化版本时，以重写或增加新方法的方式继承现有的类。（写子类）
	- 需要定义一群子类的模板，又不想让程序员初始化模板时，设计抽象类。
	- 定义出类可以扮演的角色，使用接口。  
	
    （类来自单亲家庭<只继承一个父类>，但是可以扮演不同的角色）

#### Super
不打算覆盖原来的方法，只是加入额外的动作。  
父类有非private方法method()，子类用 super.method()来调用父类的方法。.  

Super关键字是用来引用父类对象的。  
 
